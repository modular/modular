# ===----------------------------------------------------------------------=== #
#
# This file is Modular Inc proprietary.
#
# ===----------------------------------------------------------------------=== #

from array import array
from pathlib import Path
from typing import Union
from traceback import FrameSummary

import numpy as np
from max import mlir

__version__: str

def load_modular_dialects(registry: mlir.DialectRegistry) -> None: ...
def graph(
    module: mlir.Module,
    loc: mlir.Location,
    name: str,
    function_type: mlir.FunctionType,
) -> mlir.Operation: ...
def weights_attr(
    path: Path, offset: int, type: mlir.Type, name: str
) -> mlir.Attribute: ...
def array_attr(
    name: str, data: Union[array, bytes, np.ndarray], type: mlir.Type
) -> mlir.Attribute: ...
def dim_param_decl_attr(ctx: mlir.Context, name: str) -> mlir.Attribute: ...
def dim_param_decl_array_attr(
    ctx: mlir.Context, dims: list[mlir.Attribute]
) -> mlir.Attribute: ...
def shape_attr(
    ctx: mlir.Context, dims: list[mlir.Attribute]
) -> mlir.Attribute: ...
def device_attr(ctx: mlir.Context, label: str, id: int) -> mlir.Attribute: ...
def device_attr_get_label(attr: mlir.Attribute) -> str: ...
def device_attr_get_id(attr: mlir.Attribute) -> int: ...
def dtype_type(ctx: mlir.Context, dtype: str) -> mlir.Type: ...
def tensor_type(
    ctx: mlir.Context, dtype: mlir.Type, dims: list[mlir.Attribute]
) -> mlir.Type: ...
def tensor_type_with_device(
    ctx: mlir.Context,
    dtype: mlir.Type,
    dims: list[mlir.Attribute],
    device: mlir.Attribute,
) -> mlir.Type: ...
def tensor_type_get_dtype(type: mlir.Type) -> str: ...
def tensor_type_get_rank(type: mlir.Type) -> int: ...
def tensor_type_get_dim(type: mlir.Type, dim: int) -> mlir.Attribute: ...
def tensor_type_get_device(type: mlir.Type) -> mlir.Attribute: ...
def buffer_type(
    ctx: mlir.Context, dtype: mlir.Type, dims: list[mlir.Attribute]
) -> mlir.Type: ...
def buffer_type_with_device(
    ctx: mlir.Context,
    dtype: mlir.Type,
    dims: list[mlir.Attribute],
    device: mlir.Attribute,
) -> mlir.Type: ...
def buffer_type_get_dtype(type: mlir.Type) -> str: ...
def buffer_type_get_rank(type: mlir.Type) -> int: ...
def buffer_type_get_dim(type: mlir.Type, dim: int) -> mlir.Attribute: ...
def buffer_type_get_device(type: mlir.Type) -> mlir.Attribute: ...
def static_dim(ctx: mlir.Context, dim: int) -> mlir.Attribute: ...
def symbolic_dim(ctx: mlir.Context, name: str) -> mlir.Attribute: ...
def algebraic_dim(
    ctx: mlir.Context, opcode: int, lhs: mlir.Attribute, rhs: mlir.Attribute
) -> mlir.Attribute: ...
def is_symbolic_dim(attr: mlir.Attribute) -> bool: ...
def is_algebraic_dim(attr: mlir.Attribute) -> bool: ...
def is_static_dim(attr: mlir.Attribute) -> bool: ...
def static_dim_value(attr: mlir.Attribute) -> int: ...
def symbolic_dim_name(attr: mlir.Attribute) -> str: ...
def algebraic_dim_opcode(attr: mlir.Attribute) -> int: ...
def algebraic_dim_operands(attr: mlir.Attribute) -> list[mlir.Attribute]: ...
def type_is_tensor(type: mlir.Type) -> bool: ...
def type_is_opaque(type: mlir.Type) -> bool: ...
def type_is_buffer(type: mlir.Type) -> bool: ...
def type_is_chain(type: mlir.Type) -> bool: ...
def opaque_type(ctx: mlir.Context, name: str) -> mlir.Type: ...
def opaque_type_name(type: mlir.Type) -> str: ...
def chain_type(ctx: mlir.Context) -> mlir.Type: ...

# These functions store call frames directly on location objects.
# This keeps pointers to function frames for the lifetime of the mlir context.
# It will free them when the context is freed.
def frame_loc(
    ctx: mlir.Context, frame: list[FrameSummary]
) -> mlir.Location: ...
def get_frame(loc: mlir.Location) -> list[FrameSummary]: ...
