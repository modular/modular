# ===----------------------------------------------------------------------=== #
#
# This file is Modular Inc proprietary.
#
# ===----------------------------------------------------------------------=== #

from array import array
from pathlib import Path
from typing import Union

import numpy as np
from max import mlir

__version__: str

def load_modular_dialects(registry: mlir.DialectRegistry) -> None: ...
def graph(
    module: mlir.Module,
    loc: mlir.Location,
    name: str,
    function_type: mlir.FunctionType,
) -> mlir.Operation: ...
def weights_attr(
    path: Path, offset: int, type: mlir.Type, name: str
) -> mlir.Attribute: ...
def array_attr(
    name: str, data: Union[array, bytes, np.ndarray], type: mlir.Type
) -> mlir.Attribute: ...
def dim_param_decl_attr(ctx: mlir.Context, name: str) -> mlir.Attribute: ...
def dim_param_decl_array_attr(
    ctx: mlir.Context, dims: list[mlir.Attribute]
) -> mlir.Attribute: ...
def shape_attr(ctx: mlir.Context, dims: list[mlir.Attribute]) -> mlir.Type: ...
def dtype_type(ctx: mlir.Context, dtype: str) -> mlir.Type: ...
def tensor_type(
    ctx: mlir.Context, dtype: mlir.Type, dims: list[mlir.Attribute]
) -> mlir.Type: ...
def tensor_type_get_dtype(type: mlir.Type) -> str: ...
def tensor_type_get_rank(type: mlir.Type) -> int: ...
def tensor_type_get_dim(type: mlir.Type, dim: int) -> mlir.Attribute: ...
def static_dim(ctx: mlir.Context, dim: int) -> mlir.Attribute: ...
def symbolic_dim(ctx: mlir.Context, name: str) -> mlir.Attribute: ...
def is_symbolic_dim(attr: mlir.Attribute) -> bool: ...
def is_symbolic_expression_dim(attr: mlir.Attribute) -> bool: ...
def is_static_dim(attr: mlir.Attribute) -> bool: ...
def dim_static_value(attr: mlir.Attribute) -> int: ...
def dim_symbolic_name(attr: mlir.Attribute) -> str: ...
def type_is_tensor(type: mlir.Type) -> bool: ...
def type_is_opaque(type: mlir.Type) -> bool: ...
def opaque_type(ctx: mlir.Context, name: str) -> mlir.Type: ...
def opaque_type_name(type: mlir.Type) -> str: ...
